control = nls.lm.control(nprint=1)
)
p.0 <- list(k_f1=10, k_r1=0.1, kcat_2=8)
t <- ssd_objective(p.0,
parameters,
state,
names(state),
times,
data)
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)^2
print(ssqres)
# Sum all terms
out <- sum(ssqres)
return(out)
}
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)^2
print(ssqres)
# Sum all terms
out <- sum(ssqres)
return(out)
}
t <- ssd_objective(p.0,
parameters,
state,
names(state),
times,
data)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)^2
# Sum all terms
out <- sum(ssqres)
print(out)
return(out)
}
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
## values over which to simulate data
x <- seq(0,5,length=100)
## model based on a list of parameters
getPred <- function(parS, xx) parS$a * exp(xx * parS$b) + parS$c
## parameter values used to simulate data
pp <- list(a=9, b=-1, c=6)
## simulated data, with noise
simDNoisy <- getPred(pp,x) + rnorm(length(x),sd=.1)
## residual function
residFun <- function(p, observed, xx) observed - getPred(p,xx)
## starting values for parameters
parStart <- list(a=3, b=-.001, c=1)
residFun(parStart, simDNoisy, x)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)
# Sum all terms
out <- unlist(ssqres)
print(out)
return(out)
}
listReplace <- function(list1, list2) {
list1.names <- names(list1)
list2.names <- names(list2)
for (i in seq_along(list1.names)) {
if (list1.names[i] %in% list2.names) {
eval(parse(text=paste0("list2[['", list1.names[i], "']] <- list1[[i]]")))
}
}
return(list2)
}
parameters <- c(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
state <- c(Prot = 3, A = 0, B = 5, C_1 = 0, C_2 = 0, Enz = 0.5, P = 0, I = 0, I.Prot = 0)
times <- seq(0, 15, by = 0.1)
out <- ode(y = state, times = times, func = myModel, parms = parameters)
# Perform Parameter Estimation of k_f1/k_r1
data <- read_excel("C:/Users/ju61191/Desktop/tutorial_example_data.xlsx")
p.0 <- list(k_f1=10, k_r1=0.1, kcat_2=8)
t <- ssd_objective(p.0,
parameters,
state,
names(state),
times,
data)
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)
# Sum all terms
out <- unname(unlist(ssqres))
print(out)
return(out)
}
p.0 <- list(k_f1=5, k_r1=0.1, kcat_2=2)
t <- ssd_objective(p.0,
parameters,
state,
names(state),
times,
data)
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# We need to create an objective function that read in our ode solution on the parameters
ssd_objective <- function(par.to.estimate,
par.in.model,
ics.in.model,
var.in.model,
time,
observed.data) {
# Unpack parameters
par.to.run <- listReplace(par.to.estimate, par.in.model)
# Rework time variable to include time points in obv data
times <- time
tvs   <- sort(unique(c(times, as.numeric(unlist(observed.data[,1])))))
# Run ODE solver to get concentration values
out <- ode(y = ics.in.model,
times = tvs,
func = myModel,
parms = par.to.run)
# Remove time points from simulated data to match observed
df <- data.frame(out)
df <- df[df[,1] %in% as.numeric(unlist(observed.data[,1])),]
# Get columns for observed data (remove time column)
df.expected <- observed.data[,-1]
expected.names <- colnames(df.expected)
# Remove excess rows and columns from predicted data
df.pred <- df[,expected.names]
# Evaluate predicted data - expected
ssqres <- (df.pred - df.expected)
# Sum all terms
out <- unname(unlist(ssqres))
# print(out)
return(out)
}
p.0 <- list(k_f1=5, k_r1=0.1, kcat_2=2)
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
View(nls.out)
parameters[["k_f1"]]   <- nls.out$par[1]
parameters[["k_r1"]]   <- nls.out$par[2]
parameters[["kcat_2"]] <- nls.out$par[3]
parameters
# Unpack Parameters
parameters <- c(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
parameters[["k_f1"]]   <- nls.out$par[1]
parameters[["k_r1"]]   <- nls.out$par[2]
parameters[["kcat_2"]] <- nls.out$par[3]
parameters
# Unpack Parameters
parameters <- c(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
parameters
parameters["k_f1"]   <- nls.out$par[1]
parameters
# Unpack Parameters
parameters <- c(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
parameters["k_f1"]   <- nls.out$par[1]
parameters["k_r1"]   <- nls.out$par[2]
parameters["kcat_2"] <- nls.out$par[3]
parameters
# Unpack Parameters
parameters <- c(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
parameters$k_f1   <- nls.out$par[1]
View(parameters)
parameters <- list(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
state <- c(Prot = 3, A = 0, B = 5, C_1 = 0, C_2 = 0, Enz = 0.5, P = 0, I = 0, I.Prot = 0)
times <- seq(0, 15, by = 0.1)
out <- ode(y = state, times = times, func = myModel, parms = parameters)
# Unpack and plot
t <- out[,1]
a <- out[,3]
b <- out[,4]
p <- out[,8]
df <- data.frame(t,a,b,p)
df.m <- reshape2::melt(df, id.vars="t")
ggplot(df.m, aes(x=t, y=value, col=variable)) +
geom_line()
# Perform Parameter Estimation of k_f1/k_r1
data <- read_excel("C:/Users/ju61191/Desktop/tutorial_example_data.xlsx")
p.0 <- list(k_f1=5, k_r1=0.1, kcat_2=2)
nls.out <- nls.lm(par = p.0,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# Unpack Parameters
parameters[["k_f1"]]   <- nls.out$par[1]
parameters[["k_r1"]]   <- nls.out$par[2]
parameters[["kcat_2"]] <- nls.out$par[3]
parameters
nls.out$par[1]
parameters <- list(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
# Unpack Parameters
parameters[["k_f1"]]   <- unlist(nls.out$par[1])
parameters
unlist(nls.out$par[1])
unname(unlist(nls.out$par[1])
)
# Unpack Parameters
parameters[["k_f1"]]   <- unname(unlist(nls.out$par[1]))
parameters
parameters <- list(k_f1 = 2, k_r1 = 1, Km_2 = 0.1, kcat_2 = 3, k_f3 = 2, k_f4 = 2, k_s5 = 0.5, k_d6 = 0.1)
# Unpack Parameters
parameters[["k_f1"]]   <- unname(unlist(nls.out$par[1]))
parameters[["k_r1"]]   <- unname(unlist(nls.out$par[2]))
parameters[["kcat_2"]] <- unname(unlist(nls.out$par[3]))
parameters
out <- ode(y = state, times = times, func = myModel, parms = parameters)
t <- out[,1]
a <- out[,3]
b <- out[,4]
p <- out[,8]
df <- data.frame(t,a,b,p)
df.m <- reshape2::melt(df, id.vars="t")
ggplot(df.m, aes(x=t, y=value, col=variable)) +
geom_line()
ggplot(df.m, aes(x=t, y=value, col=variable)) +
geom_line() +
geom_point(df.m, aes(x=t, y=value, col=variable))
View(data)
data.m <- reshape2::melt(data, id.vars="Time")
View(data.m)
ggplot(df.m, aes(x=t, y=value, col=variable)) +
geom_line() +
geom_point(data, aes(x=t, y=value, col=variable))
ggplot(df.m, aes(x=t, y=value, group=variable)) +
geom_line() +
geom_point(data, aes(x=t, y=value, col=variable))
colnames(data)[1] <- "t"
data.m <- reshape2::melt(data, id.vars="t")
View(data.m)
ggplot(df.m, aes(x=t, y=value, group=variable)) +
geom_line() +
geom_point(data.m, aes(x=t, y=value, col=variable))
ggplot(df.m, aes(x=t, y=value, col=variable)) +
geom_line() +
geom_point(data.m, aes(x=t, y=value, col=variable))
ggplot() +
geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value, col=variable))
ggplot() +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value, col=variable))
ggplot() +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value, colour=variable))
ggplot(df.m) +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value, colour=variable))
ggplot(df.m) +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value))
data.m
ggplot(NULL, aes(x=t, y=value, col=variable)) +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m, aes(x=t, y=value))
ggplot(NULL, aes(x=t, y=value, col=variable)) +
#geom_line(df.m, aes(x=t, y=value, col=variable)) +
geom_point(data.m)
View(data.m)
ggplot(NULL, aes(x=t, y=value, col=variable)) +
geom_point(data.m)
ggplot(NULL, aes(x=t, y=value, col=variable)) +
geom_line(df.m) +
geom_point(data.m)
ggplot(NULL, aes(x=t, y=value, col=variable)) +
geom_line(df.m)
ggplot() +
geom_point(data = df.m, aes(t, value))
ggplot() +
geom_point(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
ggplot() +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
ggplot() +
geom_line(data = df.m, aes(t, value, variable)) +
geom_point(data = data.m, aes(t, value))
ggplot(aes(col=variable)) +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
ggplot(NULL, aes(col=variable)) +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
View(data.m)
View(df.m)
t <- out[,1]
A <- out[,3]
B <- out[,4]
P <- out[,8]
df <- data.frame(t,a,b,p)
df.m <- reshape2::melt(df, id.vars="t")
colnames(data)[1] <- "t"
data.m <- reshape2::melt(data, id.vars="t")
ggplot(NULL, aes(col=variable)) +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
View(df.m)
df <- data.frame(t,A,B,P)
df.m <- reshape2::melt(df, id.vars="t")
colnames(data)[1] <- "t"
data.m <- reshape2::melt(data, id.vars="t")
ggplot(NULL, aes(col=variable)) +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
lower <- c(0,0,0)
upper <- c(10, 4, 10)
lower <- c(0,0,0)
# Perform Parameter Estimation of k_f1/k_r1
data <- read_excel("C:/Users/ju61191/Desktop/tutorial_example_data.xlsx")
p.0 <- list(k_f1=5, k_r1=0.1, kcat_2=2)
upper <- c(10, 4, 10)
lower <- c(0,0,0)
nls.out <- nls.lm(par = p.0,
lower = lower,
upper = upper,
fn = ssd_objective,
par.in.model = parameters,
ics.in.model = state,
var.in.model = names(state),
time = times,
observed.data = data,
control = nls.lm.control(nprint=1)
)
# Unpack Parameters
parameters[["k_f1"]]   <- unname(unlist(nls.out$par[1]))
parameters[["k_r1"]]   <- unname(unlist(nls.out$par[2]))
parameters[["kcat_2"]] <- unname(unlist(nls.out$par[3]))
parameters
out <- ode(y = state, times = times, func = myModel, parms = parameters)
t <- out[,1]
A <- out[,3]
B <- out[,4]
P <- out[,8]
df <- data.frame(t,A,B,P)
df.m <- reshape2::melt(df, id.vars="t")
colnames(data)[1] <- "t"
data.m <- reshape2::melt(data, id.vars="t")
ggplot(NULL, aes(col=variable)) +
geom_line(data = df.m, aes(t, value)) +
geom_point(data = data.m, aes(t, value))
